{"name":"Kanji","tagline":"Web declarative component framework","body":"Kanji 感じ\r\n==========\r\n\r\n[![Build Status](https://travis-ci.org/tnhu/kanji.png?branch=master)](https://travis-ci.org/tnhu/kanji)\r\n\r\nKanji is a web declarative component framework. The idea behind Kanji is when you develop a web component, HTML and CSS should come first, then JavaScript only gets involved when user interactions happen. Kanji defines a small set of custom HTML data attributes and simple JavaScript APIs to build elegant, standardized, extensible, and testable web components.\r\n\r\nDesign philosophy:\r\n\r\n1. HTML and CSS first. A web component starts with its viewable presentation. Even with JavaScript disabled, users are able to view the content. JavaScript involves only when needed.\r\n2. HTML should be readable in the way that it's connected to both CSS (how the content looks) and JavaScript (which does what when an event happens).\r\n3. Event bindings among DOM elements and JavaScript handlers should not be verbose and painful.\r\n4. A component should be an isolated piece of software. Components interact with other components by events, not APIs.\r\n\r\nKanji is small. When being minimized and gziped, standalone version is about 1.7K, full version including dependencies (without jQuery) is less than 2.6K.\r\n\r\n## Setup\r\n\r\nIn your web page, import Kanji and its dependencies separately:\r\n\r\n``` html\r\n<script src=\"lib/jquery.js\"></script>\r\n<script src=\"lib/jsface.js\"></script>\r\n<script src=\"lib/jsface.ready.js\"></script>\r\n<script src=\"kanji.js\"></script>\r\n```\r\n\r\nOr import Kanji full version which includes jsface and jsface.ready:\r\n\r\n``` html\r\n<script src=\"lib/jquery.js\"></script>\r\n<script src=\"kanji-full.js\"></script>\r\n```\r\n\r\n## Short tutorial\r\n\r\nAssume you have an HTML fragment like below for a login form with two input fields and one submit button.\r\n\r\n``` html\r\n<form>\r\n  <input name=\"username\"></input>\r\n  <input type=\"password\" name=\"password\"></input>\r\n  <input type=\"submit\" value=\"Login\"></input>\r\n</form>\r\n```\r\n\r\nYou declare the fragment as a Kanji component by adding extra information into it via data attributes (`data-*`).\r\n\r\n``` html\r\n<form data-com=\"LoginForm\" data-cfg=\"{ 'debug': true }\">\r\n  <input name=\"username\"></input>\r\n  <input type=\"password\" name=\"password\"></input>\r\n  <input type=\"submit\" value=\"Login\"></input>\r\n</form>\r\n```\r\n\r\nNext you implement LoginForm:\r\n\r\n``` js\r\nClass(Kanji, {          // a component is a sub-class of Kanji\r\n  id: 'LoginForm',      // id is component unique identifier\r\n\r\n  actions: {            // mapping actions\r\n    '[name=username]': 'keydown:checkUsername|keyup:checkUsername',\r\n    '[name=password]': 'keydown:checkPassword',\r\n    '[type=submit]':   'login'\r\n  },\r\n\r\n  init: function(form, config) {\r\n    console.log('initialization');\r\n  },\r\n\r\n  checkUsername: function(event, input) {\r\n    console.log('checking username');\r\n  },\r\n\r\n  checkPassword: function(event, input) {\r\n    console.log('checking password');\r\n  },\r\n\r\n  login: function(event, input) {\r\n    console.log('about to login');\r\n    return false;\r\n  }\r\n});\r\n```\r\n\r\nWhat happens here is you declare the form as a component named `LoginForm` with three actions `checkUsername`, `checkPassword` and `login`. `checkUsername` is bound to `keydown` and `keyup` events on the username field, `checkPassword` handles `keydown` event on password field and `login` handles `click` event on the submit button (click event is default event so you don't have to specify `click:login`).\r\n\r\nImport the script in the same page with the HTML fragment. When you start interacting with the form, you notice the component is instantiated and its handlers are executed (open your browser JavaScript console first). You can play with [this sample online](http://jsfiddle.net/tannhu/H4fTe/15/).\r\n\r\n## Reference\r\n\r\n### HTML data attributes\r\n\r\nKanji defines two custom HTML data attributes to declare a component and its configuration.\r\n\r\n| Name                                | Required  |\r\n| ----------------------------------- | --------- |\r\n| data-com=\"ComponentNameAsString\"    | yes       |\r\n| data-cfg=\"Any\"                      | no        |\r\n\r\n#### data-com\r\n\r\nAdd `data-com=\"YourComponentId\"` into any HTML elements to declare it's a component. For example:\r\n\r\n``` html\r\n<div data-com=\"LoginForm\">\r\n</div>\r\n```\r\n\r\nComponents can be nested:\r\n\r\n``` html\r\n<div data-com=\"Page\">\r\n  <div data-com=\"Table\">\r\n    <div data-com=\"Cell\">\r\n    </div>\r\n    <div data-com=\"Cell\">\r\n    </div>\r\n  </div>\r\n  <div data-com=\"Table\">\r\n  </div>\r\n</div>\r\n```\r\n\r\n#### data-cfg\r\n\r\nThis data attribute is used to pass an extra parameter/configuration into your component.\r\n\r\n``` html\r\n<div data-com=\"LoginForm\" data-cfg=\"{ 'debug': true }\">\r\n</div>\r\n```\r\n\r\n### JavaScript API\r\n\r\n#### id, type, and lazy\r\n\r\nA component is a class extends from Kanji with a unique component id.\r\n\r\n``` js\r\nLoginForm = Class(Kanji, {\r\n  id: 'LoginForm'\r\n});\r\n```\r\n\r\nKanji supports two component types: instance and shared components. With instance component, one instance of the component is instantiated per its HTML fragment declaration. With shared component, only one instance of the component is instantiated to handle all HTML fragment declarations. Specifying shared component by adding `type: 'shared'` in component implementation:\r\n\r\n``` js\r\nLoginForm = Class(Kanji, {\r\n  id: 'LoginForm',\r\n  type: 'shared'\r\n});\r\n```\r\n\r\nBy default, all components are lazy instantiated. Meaning a JavaScript instance of the component will be created on demand, when there's a need of creating it (normally when an event happens inside the component DOM). If you want your component to be initialized right away when its DOM fragment is ready, specify `lazy: false`.\r\n\r\n``` js\r\nLoginForm = Class(Kanji, {\r\n  id: 'LoginForm',\r\n  lazy: false\r\n});\r\n```\r\n\r\n#### init() and render()\r\n\r\ninit() is the place to handle some initialization when component DOM is ready:\r\n\r\n``` js\r\nLoginForm = Class(Kanji, {\r\n  id: 'LoginForm',\r\n\r\n  init: function(container, config) {\r\n  }\r\n});\r\n```\r\n\r\n* `container`: jQuery object represents the component element (HTML)\r\n* `config`: configuration declared in the component (if any)\r\n\r\nIf you want to do some rendering when component DOM is ready, implement render() method. render() is invoked right after init().\r\n\r\n``` js\r\nLoginForm = Class(Kanji, {\r\n  id: 'LoginForm',\r\n\r\n  render: function(container) {\r\n  }\r\n});\r\n```\r\n\r\n* `container`: jQuery object represents the component element (HTML)\r\n\r\n#### actions\r\n\r\n`actions` is used to map HTML elements inside the component with events and handlers. Each entry in `actions` is a set of CSS selector to an HTML element, event names, and handler names.\r\n\r\n``` js\r\nClass(Kanji, {\r\n  id: 'LoginForm',\r\n\r\n  actions: {\r\n    '[name=username]': 'keydown:checkUsername|keyup:checkUsername',\r\n    '[name=password]': 'keydown:checkPassword',\r\n    '[type=submit]':   'login'\r\n  },\r\n\r\n  checkUsername: function(event, input) {\r\n    console.log('checking username');\r\n  },\r\n\r\n  checkPassword: function(event, input) {\r\n    console.log('checking password');\r\n  },\r\n\r\n  login: function(event, input) {\r\n    console.log('about to login');\r\n    return false;\r\n  }\r\n});\r\n```\r\n\r\nKanji supports inheritance in `actions`. A sub-class inherits actions from its parent. It can also redefine them, or add more actions.\r\n\r\n``` js\r\nClass(Kanji, {\r\n  id: 'Dialog',\r\n\r\n  actions: {\r\n    self: 'mouseenter:fetch|mouseout:fetch'\r\n  },\r\n\r\n  fetch: function() {\r\n  }\r\n});\r\n\r\nClass(Component, {\r\n  id: 'LoginDialog',\r\n\r\n  actions: {\r\n    self: 'mousedown:contextMenu|mouseout:contextMenu'   // inherit 'mouseenter', override 'mouseout', add 'mousedown'\r\n  },\r\n\r\n  contextMenu: function() {\r\n  }\r\n});\r\n```\r\n\r\n#### listeners and notify(): Inter-component communication\r\n\r\nA component uses `notify()` to send notifications.\r\n\r\n``` js\r\nClass(Kanji, {\r\n  id: 'LoginForm',\r\n\r\n  sayHi: function(event, target) {\r\n    this.notify('logger:info', 'Say hi');\r\n  },\r\n\r\n  sayBye: function(event, target) {\r\n    this.notify('logger:info', 'Say bye');\r\n  }\r\n});\r\n```\r\n\r\nAny components want to capture a notification need to implement a listener. For example, Logger listens to `log.info` to do logging:\r\n\r\n``` js\r\nClass(Kanji, {\r\n  id: 'Logger',\r\n\r\n  listeners: {\r\n    'logger:info': function(message) {\r\n      // do something when being notified\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nPlay with a sample [online](http://jsfiddle.net/tannhu/YFCVX/3/).\r\n\r\nLike `actions`, `listeners` in Kanji are inherited. If a parent component has some listeners, its child components will have them as default listeners. The child components are also able to override those inherited listeners.\r\n\r\n#### Namespace and listeners\r\n\r\nInstances of non-shared components are able to communicate directly via namespace mechanism. When a component is declared with a namespace, notifications sent intentionally to it must be postfixed by its namespace.\r\n\r\nGive an example ([see online](http://jsfiddle.net/tannhu/AzCdA/3/)), we have a Timer component listens to `timer:show` event like this:\r\n\r\n``` js\r\nClass(Kanji, {\r\n  id: 'Timer',\r\n\r\n  init: function() {\r\n    this.notify('timer:up');\r\n  },\r\n\r\n  listeners: {\r\n    'timer:show': function() {\r\n      // ...\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nWhen having declarations:\r\n\r\n``` html\r\n<script data-com=\"Timer/red\" data-cfg=\"{ 'src': 'Red Timer' }\"></script>\r\n<script data-com=\"Timer\" data-cfg=\"{ 'src': 'Timer1' }\"></script>\r\n<script data-com=\"Timer\" data-cfg=\"{ 'src': 'Timer2' }\"></script>\r\n<script data-com=\"Timer\" data-cfg=\"{ 'src': 'Timer3' }\"></script>\r\n```\r\n\r\nThe call from a component:\r\n\r\n``` js\r\nthis.notify('timer:show');\r\n```\r\n\r\nnotifies Timer1, Timer2, and Timer3, and Red Timer. The call:\r\n\r\n``` js\r\nthis.notify('timer:show/red');\r\n```\r\n\r\nnotifies Red Timer. But not Timer1, Timer2, and Timer3.\r\n\r\nListeners also support namespace.\r\n\r\n``` js\r\nClass(Kanji, {\r\n  id: 'Listener',\r\n\r\n  listeners: {\r\n    /**\r\n     * Listen to 'timer:up' event on Timer with namespace 'red'\r\n     */\r\n    'timer:up/red': function() {\r\n    },\r\n\r\n    /**\r\n     * Listen to 'timer:up' event on all timers (Red timer include)\r\n     */\r\n    'timer:up': function() {\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nKanji implements simple namespace notify/listeners routing. In the example above, if Listener component is also namespaced, then it won't work as expected.\r\n\r\nI would recommend to prefix notification id by component name in lowercase (`Timer` -> `timer:up`) to make the code consistent and easy to lookup.\r\n\r\n#### Inheritance and extending\r\n\r\nPowered by [jsface](https://github.com/tannhu/jsface), Kanji allows multiple level inheritance. Subclass can override and invoke parent's actions (methods).\r\n\r\n``` js\r\nComponent = Class(Kanji, {\r\n  id: 'Component',\r\n\r\n  openModal: function(event, target) {\r\n    // ...\r\n  }\r\n});\r\n\r\nDialog = Class(Component, {\r\n  id: 'Dialog',\r\n\r\n  openModal: function(event, target) {\r\n    // do something specifically for Dialog\r\n\r\n    // call Component's openModal\r\n    Dialog.$superp.openModal.call(this, event, target);\r\n  }\r\n});\r\n\r\nLoginDialog = Class(Component, {\r\n  id: 'LoginDialog',\r\n\r\n  openModal: function(event, target) {\r\n    // do something specifically for LoginDialog\r\n\r\n    // call Dialog's openModal\r\n    LoginDialog.$superp.openModal.call(this, event, target);\r\n  }\r\n});\r\n```\r\n\r\n#### Kanji internal notifications\r\n\r\nKanji has three internal notifications:\r\n\r\n| Name                                | Description                             |\r\n| ----------------------------------- | --------------------------------------- |\r\n| com:not-found                       | Component implementation not found      |\r\n| com:init                            | Re-init a component                     |\r\n| com:config-not-wellformed           | Component configuration not well-formed |\r\n\r\n`com:not-found` is fired when Kanji tries to initialize a component but its implementation is not found. Frameworks built on top of Kanji can capture this notification to do some handy stuff like fetching scripts or error reporting, etc.\r\n\r\nYou are able to force Kanji to initialize/re-init a component by sending a `com:init` notification.\r\n\r\n**Syntax:**\r\n\r\n``` js\r\nKanji.notify('com:init', container);\r\n```\r\n\r\nWhat is the use of `com:init` notification? It's useful when you detach HTML fragment of a component which has actions bound to costly events (like `mouseenter`, `mouseout`, `mousemove`, `mouseleave`, `mouseover`, `hover`) then later on attach the fragment. In such situation, you need to tell Kanji to re-initialize the component again in order to make event handlers work properly.\r\n\r\n#### Kanji reserved properties\r\n\r\nWhen implementing your components, note that Kanji reserves these properties for its internal use.\r\n\r\n| Name                                | Required  |\r\n| ----------------------------------- | --------- |\r\n| id                                  | yes       |\r\n| type                                | no        |\r\n| lazy                                | no        |\r\n| actions                             | no        |\r\n| listeners                           | no        |\r\n| namespace                           | no        |\r\n\r\n## Best practice\r\n\r\nI would recommend to define a root class component which includes shared methods (APIs). Other components extend the root component (or its subclass) rather than inheriting from Kanji directly. And it would be always better to group your components under a namespace instead of making a lot of global variables.\r\n\r\n``` js\r\nLI = {};\r\nLI.Component = Class(Kanji, {\r\n  id: 'Component'\r\n\r\n  // shared methods\r\n});\r\n\r\nLI.LoginForm = Class(LI.Component, {\r\n  id: 'LoginForm'\r\n\r\n  // ...\r\n});\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}